#!/usr/bin/env python3
import re
import os
import time
import math
import requests
import argparse
import subprocess
from pathlib import Path
from colorama import Fore, Back, Style


# Ridiculous, Obligatory Title
obligatory_title = '''
   ______                      __                ______                                      __            
  / ____/________  ___  ____ _/ /_____  _____   / ____/___  __  ______ ___  ___  _________ _/ /_____  _____
 / /   / ___/ __ \/ _ \/ __ `/ //_/ _ \/ ___/  / __/ / __ \/ / / / __ `__ \/ _ \/ ___/ __ `/ __/ __ \/ ___/
/ /___(__  ) /_/ /  __/ /_/ / ,< /  __(__  )  / /___/ / / / /_/ / / / / / /  __/ /  / /_/ / /_/ /_/ / /    
\____/____/ .___/\___/\__,_/_/|_|\___/____/  /_____/_/ /_/\__,_/_/ /_/ /_/\___/_/   \__,_/\__/\____/_/     
         /_/                                                                                               
'''

# User Configurations
suppression_list = ['masscan', 'dotdotpwn', ]       # List of tools that should use a suppression
suppression = ' >/dev/null 2>&1'                    # Suppression standard postfix
disabled_cmd_dict = {                               # <Tool>: <Reason_For_Disabled_State>
    'dotdotpwn': 'Disabled due to inability to grep output or control it without user intervention.',
    'masscan': 'Disabled due to runtime.',
    'nikto': 'Disabled due to OSCP requirements.'
}


def get_args():
    global obligatory_title
    print(obligatory_title)
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--ip', help='Target IP Address', default='BLANK', type=str, required=True)
    parser.add_argument('-rpc', '--rpc_port', help='Target RPC Port', default=111, type=int, required=False)
    parser.add_argument('-s', '--scan_type', help='Scan Speed: [`long` or `short`]', default='short', type=str,
                        required=False)
    parser.add_argument('-c', '--command_timeout', help='Command Timeout [Default = 30 Minutes]', default=3000,
                        type=int, required=False)
    parser.add_argument('-ftp', '--ftp_port', help='Target FTP Port', default=21, type=int, required=False)
    parser.add_argument('-ssh', '--ssh_port', help='Target SSH Port', default=22, type=int, required=False)
    parser.add_argument('-smtp', '--smtp_port', help='Target SMTP Port', default=25, type=int, required=False)
    parser.add_argument('-dns', '--dns_port', help='Target SSH Port', default=53, type=int, required=False)
    parser.add_argument('-pop', '--pop_port', help='Target POP Port', default=110, type=int, required=False)
    parser.add_argument('-smb', '--smb_port', help='Target SMB Port', default=139, type=int, required=False)
    parser.add_argument('-snmp', '--snmp_port', help='Target SNMP Port', default=161, type=int, required=False)
    parser.add_argument('-http', '--http_port', help='Target HTTP Port', default=80, type=int, required=False)
    parser.add_argument('-https', '--https_port', help='Target HTTPs Port', default=443, type=int, required=False)
    parser.add_argument('-nosudo', '--nosudo', help='Don\'t Initiate Sudo', action='store_true', default=False)
    return parser.parse_args()


# Global Variables
script_path = os.path.abspath(__file__)
script_dir = os.path.dirname(script_path)
wordlist_root = 'wordlists'
superuser = 'sudo '                 # Sudo Privs if required.
port_list = []
args = get_args()
cmd_timeout = args.command_timeout
scan_type = args.scan_type
ip = args.ip
rpc_port = args.rpc_port
http_port = args.http_port
https_port = args.https_port
ftp_port = args.ftp_port
ssh_port = args.ssh_port
smtp_port = args.smtp_port
dns_port = args.dns_port
pop_port = args.pop_port
smb_port = args.smb_port
snmp_port = args.snmp_port
socket_dict = {}
output_root_dir = f"{'/'.join(os.getcwd().split('/')[:-1])}/{ip}_results"
http_socket = f'http://{ip}:{http_port}'
http_filename = http_socket.replace('http://', '').replace('//', '').replace('/', '-')
https_socket = f'https://{ip}:{https_port}'
https_filename = https_socket.replace('https://', '').replace('//', '').replace('/', '-')
original_start_time = time.time()
current_process_time = time.time()
initial_ports = ''
output_summary = []

# Service / Port Definitions
service_dict = {
    'initial': 'initial',
    'wordlist': 'wordlist',
    'all': 'all',
    f'{ftp_port}': 'ftp',
    f'{ssh_port}': 'ssh',
    f'{smtp_port}': 'smtp',
    f'{dns_port}': 'dns',
    f'{http_port}': 'http',
    f'{pop_port}': 'pop',
    f'{rpc_port}': 'rpc',
    f'{smb_port}': 'smb',
    f'{snmp_port}': 'snmp',
    f'{https_port}': 'https',
    '445': 'smb',
    '1521': 'oracle',
    '3306': 'mysql',
}


# Command Sets
def generate_command_dict():    # Dynamically generates command sets based on the provided and identified data.
    global ip, port_list, rpc_port, http_port, https_port, http_socket, https_socket, http_filename, https_filename
    global wordlist_root, output_root_dir, args, initial_ports

    command_sets_dict = {
        'initial': {
            'commands': {
                f'nmap -p{initial_ports} -sC -sV -O -A {ip} | tee -a {output_root_dir}/nmap_summary': ['LONG', 'SHORT'],
                f'masscan -p U:1-65535 {ip} --rate=1000 | tee -a {output_root_dir}/masscan_summary': ['LONG', 'SHORT'],
            }
        },
        
        'dns': {
            'commands': {
                f'dig axfr {ip} | tee -a {output_root_dir}/dns_summary': ['LONG', 'SHORT'],
                f'nmap -n --script '
                f'"(default and *dns*) or fcrdns or dns-srv-enum or dns-random-txid or dns-random-srcport" '
                f'{ip} | tee -a {output_root_dir}/dns_summary': ['LONG', 'SHORT'],
                f'dnsrecon -r {ip}/24 -n {ip} | tee -a {output_root_dir}/dns_summary': ['LONG', 'SHORT'],
                f'dnsrecon -d {output_root_dir}/dns_summary_2 -a -n {ip}': ['LONG', 'SHORT'],
            }
        },

        'ftp': {
            'commands': {
                f'nmap --script ftp-* -p {args.ftp_port} {ip} | tee -a {output_root_dir}/ftp_summary':['LONG', 'SHORT'],
            }
        },

        'smtp': {
            'commands': {
                f'nmap â€“script smtp-commands,smtp-enum-users -p 25 {ip} '
                f'| tee {output_root_dir}/smtp_summary': ['LONG', 'SHORT'],
            }
        },

        'http': {
            'commands': {
                f'dirb {http_socket} {wordlist_root}/small.txt -x extensions.txt '
                f'-r -l -S -i -f | tee -a {output_root_dir}/dirb_summary': ['LONG', 'SHORT'],
                f'dotdotpwn -d 6 -m http -h {ip} -x {http_port} -b -q '
                f'| tee -a {output_root_dir}/dotdotpwn_summary': ['LONG', 'SHORT'],
                f'nikto -h {http_socket} | tee -a {output_root_dir}/nikto_summary.txt': ['LONG', 'SHORT'],
                f'gobuster dir -u {http_socket} -w {wordlist_root}/small.txt '
                f'-t 150 -x php,html,js  -s "200,204,301,302,307,403,401" | tee -a '
                f'{output_root_dir}/gobuster_summary': ['LONG', 'SHORT'],
                f'dirb {http_socket} {wordlist_root}/common.txt -x extensions.txt '
                f'-r -l -S -i -f | tee -a {output_root_dir}/dirb_summary': ['LONG'],
            }
        },

        'https': {
            'commands': {
                f'dirb {https_socket} {wordlist_root}/small.txt -x extensions.txt '
                f'-r -l -S -i -f | tee -a {output_root_dir}/dirb_{https_filename}': ['LONG'],
                f'dotdotpwn -d 6 -m http -h {ip} -x {https_port} -b -S -q | tee -a '
                f'{output_root_dir}/dotdotpwn_{https_filename}': ['LONG', 'SHORT'],
                f'nikto -h {https_socket.split(":")[0]} | tee -a '
                f'{output_root_dir}/nikto_{https_filename}.txt': ['LONG', 'SHORT'],
                f'gobuster dir -u {https_socket} -w {wordlist_root}/small.txt '
                f'-t 150 -k -x php,html,js  -s "200,204,301,302,307,403,401" | tee -a '
                f'{output_root_dir}/gobuster_{https_filename}': ['LONG', 'SHORT'],
                f'dirb {https_socket} {wordlist_root}/common.txt -x extensions.txt '
                f'-r -l -S -i -f | tee -a {output_root_dir}/dirb_{https_filename}': ['LONG'],
                f'sslyze --regular {https_socket.replace("https://", "")} | tee -a '
                f'{output_root_dir}/sslyze_{https_filename}': ['LONG', 'SHORT'],
                f'tlssled {ip} {https_port} | tee -a {output_root_dir}/tlssled_{https_filename}': ['LONG', 'SHORT'],
            }
        },

        'cgi_bin': {
            'commands': {
                f'gobuster dir -u {http_socket}/cgi-bin/ -w {wordlist_root}/small.txt '
                f'-s 302,307,200,204,301,403 -x sh,pl,py,ps -t 150 '
                f'| tee -a {output_root_dir}/cgi-bin_summary': ['LONG', 'SHORT']
            }
        },

        'rpc': {
            'commands': {
                f'rpcinfo -p {ip} | tee -a {output_root_dir}/rpc_summary': ['LONG', 'SHORT'],
            }
        },

        'smb': {
            'commands': {
                f'nbtscan -r {ip} | tee -a {output_root_dir}/smb_summary': ['LONG', 'SHORT'],
                f'enum4linux -a {ip} | tee -a {output_root_dir}/smb_summary': ['LONG', 'SHORT'],
                f'nmap -sU -sS --script=smb-enum-users -p U:137,T:139 {ip} | tee -a '
                f'{output_root_dir}/smb_summary': ['LONG', 'SHORT'],
                f'nmap {ip} --script smb-enum-domains.nse,smb-enum-groups.nse,'
                f'smb-enum-processes.nse,smb-enum-sessions.nse,smb-enum-shares.nse,smb-enum-users.nse,smb-ls.nse,'
                f'smb-mbenum.nse,smb-os-discovery.nse,smb-print-text.nse,smb-psexec.nse,smb-security-mode.nse,'
                f'smb-server-stats.nse,smb-system-info.nse,smb-vuln-conficker.nse,smb-vuln-cve2009-3103.nse,'
                f'smb-vuln-ms06-025.nse,smb-vuln-ms07-029.nse,smb-vuln-ms08-067.nse,smb-vuln-ms10-054.nse,'
                f'smb-vuln-ms10-061.nse,smb-vuln-regsvc-dos.nse | tee -a {output_root_dir}/smb_all': ['LONG', 'SHORT'],
            }
        },

        'snmp': {
            'commands': {
                f'snmpwalk -c public -v1 {ip} | tee -a {output_root_dir}/snmp_summary': ['LONG', 'SHORT'],
                f'snmpcheck -t {ip} -c public | tee -a {output_root_dir}/snmp_summary': ['LONG', 'SHORT'],
                f'onesixtyone {ip} public | tee -a {output_root_dir}/snmp_summary': ['LONG', 'SHORT'],
            }
        },

        'oracle': {
            'commands': {
                f'tnscmd10g version -h {ip} | tee -a {output_root_dir}/oracle_summary': ['LONG', 'SHORT'],
                f'tmscmd10g status -h {ip} | tee -a {output_root_dir}/oracle_summary': ['LONG', 'SHORT'],
            },
        },

        'mysql': {
            'commands': {
                f'nmap -sV -Pn -vv {ip} -p 3306 --script mysql-audit,mysql-databases,'
                f'mysql-dump-hashes,mysql-empty-password,mysql-enum,mysql-info,mysql-query,mysql-users,'
                f'mysql-variables,mysql-vuln-cve2012-2122 | tee -a {output_root_dir}/mysql_summary': ['LONG', 'SHORT'],
            }
        },

        'all': {
            'commands': {
                f'nmap -nvv -Pn- -sSV -p {initial_ports} --version-intensity 9 -A {ip} | tee '
                f'{output_root_dir}/intense_service_scan_summary': ['LONG', 'SHORT'],
            }
        },
    }
    return command_sets_dict


def chmod(_path):
    try:
        os.chmod(_path, 0o0777)
    except Exception as e:
        print_with_intention(f'[!] Path CHMOD Failed: {_path}\n\tError: `{e}`')


def build_dir_tree(_path):
    if os.path.exists(_path):
        print_with_intention(f'[i] Results Path Already Exists: `{_path}`', 'info')
        return _path
    try:
        if _path[-1] == "/":
            Path(_path[:-1]).mkdir(parents=True)
        else:
            Path(_path).mkdir(parents=True)
        print_with_intention(f'[+] Results Path Created: `{_path}`', 'good')
        chmod(_path)

    except Exception as e:
        print_with_intention(f'[!] Path Creation Error Details: `{e}`', 'bad')
        return _path
    return _path


def socket_updater(new_ip, new_port):
    global ip, http_port, https_port, http_socket, https_socket
    ip = new_ip
    http_port = new_port
    https_port = new_port
    http_socket = f'http://{ip}:{http_port}'
    https_socket = f'https://{ip}:{https_port}'
    generate_command_dict()


def print_elapsed_time():
    global original_start_time
    seconds = round(int(time.time() - original_start_time), 2)
    minutes = math.trunc(seconds / 60)
    remaining_seconds = math.trunc(seconds - (minutes * 60))
    if len(str(remaining_seconds)) != 2:
        remaining_seconds = f'0{remaining_seconds}'
    elapsed_time = f'{minutes}:{remaining_seconds}'
    msg = f'[^] Total_Time Elapsed: `{elapsed_time}`'
    print_with_intention(msg, 'info')
    return time.time()


def http_response(_url):
    r = requests.head(_url, verify=False, timeout=5)
    content_type = f"{r.headers['content-type']}"
    return f"{r.status_code}", f"{content_type}"


def get_live_sockets():
    global ip, port_list, socket_dict, service_dict
    
    for port in port_list:
        potential_sockets = {f'http://{ip}:{port}': 'http', f'https://{ip}:{port}': 'https'}
        for potential_socket, _protocol in potential_sockets.items():
            try:
                socket_response = http_response(potential_socket)
                socket_dict[f'{potential_socket}'] = f'{port}'
                service_dict[f'{port}'] = f'{_protocol}'
                print_with_intention(f'[+] Socket `{potential_socket}` responded with a `{socket_response[0]}`.')
                print_with_intention(f'[^] Adding port `{port}` to the `{_protocol}` protocol/service.')

            except Exception as e:
                print_with_intention(f'[*] Socket `{potential_socket}` failed to respond. Skipping...')
                print_with_intention(f'[x] Error Details: `{e}`')
                continue


def execute_os_command(_cmd, _print=True, _print_et=True):
    global args, suppression, suppression_list, disabled_cmd_dict, cmd_timeout

    for disabled_cmd in disabled_cmd_dict:
        if disabled_cmd in _cmd:
            msg = f'[*] Command Disabled: `{_cmd}`'
            print_with_intention(msg)
            return None, None

    for flagged_cmd in suppression_list:
        if flagged_cmd in _cmd:
            _cmd = _cmd + suppression

    if _print:
        print_with_intention(f'[i] Attempting: `{_cmd}`')

    if not args.nosudo:
        _cmd = f'{superuser}{_cmd}'

    try:
        results = subprocess.run(_cmd, shell=True, timeout=cmd_timeout, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout = results.stdout.decode()
        stderr = results.stderr.decode()

        if results.returncode == 0 and not results.stderr:
            if stdout:
                print_with_intention(f'[^] {stdout}')
            print_with_intention(f'[^] Execution Completed Successfully!')
            if _print_et:
                print_elapsed_time()
            return stdout, None

        else:
            print_with_intention(f'[!] Execution Encountered an Error.')
            if stderr:
                print_with_intention(f'[*] {stderr}')
            if _print_et:
                print_elapsed_time()
            return 'SystemExecutionError', results.stderr.decode()

    except SystemExcecutionError as e:
        print_with_intention(f'[!] System Execution Error: `{e}`')
        print_with_intention(f'[x] Exiting due to system error or permissions issue.')
        print_with_intention(f'[^] Ensure you are running in a shell and not an IDE.')

    except Exception as e:
        print_with_intention(f'[!] General Execution Failure.')
        print_with_intention(f'[*] {e}')

    if _print_et:
        print_elapsed_time()
    return None, None


def print_with_intention(_string, newline=True, tab=False):
    global output_summary
    new_line = "\n" if newline else " "
    _tab = "\t" if tab else " "

    # Informational Statement
    if _string.startswith("[i] "):
        print(_tab + Fore.WHITE + Back.BLUE + "[i]" + Back.RESET + Fore.RESET + " " +
              Style.RESET_ALL + Fore.WHITE + Back.BLUE + _string[4:] + Back.RESET + Fore.RESET + new_line)
    # Declarative Statement
    elif _string.startswith("[+] "):
        print(_tab + Fore.BLACK + Back.GREEN + "[+]" + Back.RESET + Fore.RESET + " " +
              Style.RESET_ALL + Fore.BLACK + Back.GREEN + _string[4:] + Fore.RESET + Back.RESET + new_line)
    # Addendum or Continuation
    elif _string.startswith("[^] "):
        print("\t" + Fore.BLACK + Back.CYAN + "[^]" + Back.RESET + Fore.RESET + " " +
              Style.RESET_ALL + Fore.BLACK + Back.CYAN + _string[4:] + Fore.RESET + Back.RESET + new_line)
    # Error or Alert Notification
    elif _string.startswith("[!] "):
        print(_tab + Fore.WHITE + Back.RED + "[!]" + Back.RESET + Fore.RESET + " " +
              Style.RESET_ALL + Fore.WHITE + Back.RED + _string[4:] + Fore.RESET + Back.RESET + new_line)
    # Error Details or Configuration Alert
    elif _string.startswith("[*] "):
        print("\t" + Fore.YELLOW + Back.RED + "[^]" + Back.RESET + Fore.RESET + " " +
              Style.RESET_ALL + Fore.YELLOW + Back.RED + _string[4:] + Fore.RESET + Back.RESET + new_line)
    # System Errors
    elif _string.startswith("[x] ") or _string.startswith("[X] "):
        print("\t\t" + Fore.YELLOW + Back.RED + "[x]" + Back.RESET + Fore.RESET + " " +
              Style.RESET_ALL + Fore.YELLOW + Back.RED + _string[4:] + Fore.RESET + Back.RESET + new_line)

    output_summary.append(_string)


def test_protocol(port_str):
    global service_dict, suppression_list, scan_type, disabled_cmd_dict, ip
    result = False
    command_sets = generate_command_dict()
    try:
        protocol = f'{service_dict[port_str]}'
        if protocol.lower() in ['http', 'https']:
            socket_updater(ip, port_str)
        try:
            tool_set = set(tool.split(" ")[0] for tool in command_sets[protocol]['commands'])
            try:
                cmd_dict = command_sets[protocol]['commands']
                all_tools = ", ".join(tool_set) if len(tool_set) > 1 else next(iter(tool_set))
                tools = [item for item in all_tools.split(', ') if item not in disabled_cmd_dict]
                print_with_intention(f'[i] Detected Port & Protocol: ({port_str.upper()}/{protocol.upper()})')
                print_with_intention(f'[^] Testing port with Tools: `{tools}`')
                for cmd, cmd_scan_type in cmd_dict.items():
                    if scan_type.upper() in cmd_scan_type:
                        try:
                            result = True
                            execute_os_command(cmd)
                        except Exception as e:
                            result = False
                            print_with_intention(f'[!] Command set failure for protocol: `{protocol.upper()}`')
                            print_with_intention(f'[*] Error: `{e}`')
                    else:
                        print_with_intention(f'[*] Command not in `{scan_type.upper()}` Scan Type: `{cmd}`')
            except Exception as e:
                print_with_intention(f'[!] No command set defined for protocol `{protocol.upper()}`')
                print_with_intention(f'Error: `{e}`')
        except Exception as e:
            print_with_intention(f'[!] No command set defined for port `{port_str}`')
            print_with_intention(f'Error: `{e}`')
    except Exception as e:
        print_with_intention(f'[!] No port service defined in service_dict for `{port_str}`')
        print_with_intention(f'Error: `{e}`')
    return result


def build_output_structure():
    global output_root_dir
    _dirs = [output_root_dir,
             f"{'/'.join(output_root_dir.split('/')[:-1])}/artifacts",
             f"{'/'.join(output_root_dir.split('/')[:-1])}/exploits"]
    for _dir in _dirs:
        if not os.path.exists(_dir):
            try:
                build_dir_tree(_dir)
            except:
                pass


def main():
    global ip, output_summary, port_list, output_root_dir, socket_dict, initial_ports
    generate_command_dict()
    build_output_structure()

    # Begin testing on all components.
    print_with_intention(f'[+] TARGET: `{ip}`', 'start')
    print_with_intention(f'[i] Performing Initial Port Discovery. Please wait up to 5 minutes...')
    initial_ports = execute_os_command(f"nmap -p- --min-rate=1000 -T4 {ip} "
                                       f"| grep '^[0-9]' "
                                       f"| cut -d '/' -f 1 "
                                       f"| tr '\n' ',' "
                                       f"| sed s/,$//",
                                       _print=False, _print_et=False)[0]

    port_list = [x.strip() for x in initial_ports.split(",") if x.strip()]

    test_protocol('initial')
    test_protocol('all')

    # Test each identified socket.
    get_live_sockets()
    if socket_dict:
        for _, _port in socket_dict.items():
            test_protocol(f'{_port}')

    for _port in port_list:
        if service_dict[_port] not in ['http', 'https']:
            test_protocol(_port)

    # Write the output to the summary file for this run.
    f_out = open(f'{output_root_dir}/summary_{ip}', 'w')
    for summary_line in output_summary:
        f_out.write(f'{summary_line}\n')
    f_out.close()


if __name__ == '__main__':
    main()
